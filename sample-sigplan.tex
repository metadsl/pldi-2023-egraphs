
%%
%% This is file `sample-sigplan.tex',
%% generated with the docstrip utility.
%%
%% The original source files were:
%%
%% samples.dtx  (with options: `sigplan')
%% 
%% IMPORTANT NOTICE:
%% 
%% For the copyright see the source file.
%% 
%% Any modified versions of this file must be renamed
%% with new filenames distinct from sample-sigplan.tex.
%% 
%% For distribution of the original source see the terms
%% for copying and modification in the file samples.dtx.
%% 
%% This generated file may be distributed as long as the
%% original source files, as listed above, are part of the
%% same distribution. (The sources need not necessarily be
%% in the same archive or directory.)
%%
%% Commands for TeXCount
%TC:macro \cite [option:text,text]
%TC:macro \citep [option:text,text]
%TC:macro \citet [option:text,text]
%TC:envir table 0 1
%TC:envir table* 0 1
%TC:envir tabular [ignore] word
%TC:envir displaymath 0 word
%TC:envir math 0 word
%TC:envir comment 0 0
%%
%%
%% The first command in your LaTeX source must be the \documentclass command.
\documentclass[sigplan,screen,review]{acmart}

\usepackage{dirtytalk}
\usepackage{hyperref}
\usepackage{cprotect}
\usepackage{listings}
\usepackage{fancyvrb}


%% NOTE that a single column version is required for 
%% submission and peer review. This can be done by changing
%% the \doucmentclass[...]{acmart} in this template to 
%% \documentclass[manuscript,screen,review]{acmart}
%% 
%% To ensure 100% compatibility, please check the white list of
%% approved LaTeX packages to be used with the Master Article Template at
%% https://www.acm.org/publications/taps/whitelist-of-latex-packages 
%% before creating your document. The white list page provides 
%% information on how to submit additional LaTeX packages for 
%% review and adoption.
%% Fonts used in the template cannot be substituted; margin 
%% adjustments are not allowed.
%%
%% \BibTeX command to typeset BibTeX logo in the docs
\AtBeginDocument{%
  \providecommand\BibTeX{{%
    \normalfont B\kern-0.5em{\scshape i\kern-0.25em b}\kern-0.8em\TeX}}}

%% Rights management information.  This information is sent to you
%% when you complete the rights form.  These commands have SAMPLE
%% values in them; it is your responsibility as an author to replace
%% the commands and values with those provided to you when you
%% complete the rights form.
\setcopyright{none}
% \copyrightyear{2018}
\acmYear{2023}
\acmDOI{}

%% These commands are for a PROCEEDINGS abstract or paper.
\acmConference{PLDI'23 - EGRAPHS workshop}{June 16--21,
  2023}{Orlando, FL}
%
%  Uncomment \acmBooktitle if th title of the proceedings is different
%  from ``Proceedings of ...''!
%
%\acmBooktitle{Woodstock '18: ACM Symposium on Neural Gaze Detection,
%  June 03--05, 2018, Woodstock, NY} 
\acmPrice{}
\acmISBN{}


%%
%% Submission ID.
%% Use this when submitting an article to a sponsored event. You'll
%% receive a unique submission ID from the organizers
%% of the event, and this ID should be used as the parameter to this command.
%%\acmSubmissionID{123-A56-BU3}

%%
%% For managing citations, it is recommended to use bibliography
%% files in BibTeX format.
%%
%% You can then either use BibTeX with the ACM-Reference-Format style,
%% or BibLaTeX with the acmnumeric or acmauthoryear sytles, that include
%% support for advanced citation of software artefact from the
%% biblatex-software package, also separately available on CTAN.
%%
%% Look at the sample-*-biblatex.tex files for templates showcasing
%% the biblatex styles.
%%

%%
%% The majority of ACM publications use numbered citations and
%% references.  The command \citestyle{authoryear} switches to the
%% "author year" style.
%%
%% If you are preparing content for an event
%% sponsored by ACM SIGGRAPH, you must use the "author year" style of
%% citations and references.
%% Uncommenting
%% the next command will enable that style.
%%\citestyle{acmauthoryear}

%%
%% end of the preamble, start of the body of the document source.
\begin{document}
\VerbatimFootnotes
%%
%% The "title" command has an optional parameter,
%% allowing the author to define a "short title" to be used in page headers.
\title{Egg-smol Python: A Pythonic Library for E-graphs}

%%
%% The "author" command and its associated commands are used to define
%% the authors and their affiliations.
%% Of note is the shared affiliation of the first two authors, and the
%% "authornote" and "authornotemark" commands
%% used to denote shared contribution to the research.
\author{Saul Shanabrook}
\email{s.shanabrook@gmail.com}
\orcid{0000-0002-0258-4236}

%%
%% By default, the full list of authors will be used in the page
%% headers. Often, this list is too long, and will overlap
%% other information printed in the page headers. This command allows
%% the author to define a more concise list
%% of authors' names for this purpose.
% \renewcommand{\shortauthors}{Trovato and Tobin, et al.}

%%
%% The abstract is a short summary of the work to be presented in the
%% article.

%%
%% The code below is generated by the tool at http://dl.acm.org/ccs.cfm.
%% Please copy and paste the code instead of the example below.
%%
% \begin{CCSXML}
% <ccs2012>
%  <concept>
%   <concept_id>10010520.10010553.10010562</concept_id>
%   <concept_desc>Computer systems organization~Embedded systems</concept_desc>
%   <concept_significance>500</concept_significance>
%  </concept>
%  <concept>
%   <concept_id>10010520.10010575.10010755</concept_id>
%   <concept_desc>Computer systems organization~Redundancy</concept_desc>
%   <concept_significance>300</concept_significance>
%  </concept>
%  <concept>
%   <concept_id>10010520.10010553.10010554</concept_id>
%   <concept_desc>Computer systems organization~Robotics</concept_desc>
%   <concept_significance>100</concept_significance>
%  </concept>
%  <concept>
%   <concept_id>10003033.10003083.10003095</concept_id>
%   <concept_desc>Networks~Network reliability</concept_desc>
%   <concept_significance>100</concept_significance>
%  </concept>
% </ccs2012>
% \end{CCSXML}

% \ccsdesc[500]{Computer systems organization~Embedded systems}
% \ccsdesc[300]{Computer systems organization~Redundancy}
% \ccsdesc{Computer systems organization~Robotics}
% \ccsdesc[100]{Networks~Network reliability}

%%
%% Keywords. The author(s) should pick words that accurately describe
%% the work being presented. Separate the keywords with commas.
% \keywords{datasets, neural networks, gaze detection, text tagging}

%% A "teaser" image appears between the author and affiliation
%% information and the body of the document, and typically spans the
%% page.
% \begin{teaserfigure}
%   \includegraphics[width=\textwidth]{sampleteaser}
%   \caption{Seattle Mariners at Spring Training, 2010.}
%   \Description{Enjoying the baseball game from the third-base
%   seats. Ichiro Suzuki preparing to bat.}
%   \label{fig:teaser}
% \end{teaserfigure}

% \received{20 February 2007}
% \received[revised]{12 March 2009}
% \received[accepted]{5 June 2009}

%%
%% This command processes the author and affiliation and title
%% information and builds the first part of the formatted document.

\begin{abstract}
E-graphs have emerged as a versatile data structure with applications in synthesis, optimization, and verification through techniques such as equality saturation. This paper introduces Python bindings for the experimental egg-smol library, which aims to bring the benefits of e-graphs to the Python ecosystem. The bindings offer a high-level, Pythonic API providing an accessible and familiar interface for Python users. By integrating e-graph techniques with Python, we hope to enable collaboration and innovation across various domains in the scientific computing and machine learning communities. We discuss the advantages of using Python bindings for both Python and existing egg-smol users, as well as possible future directions for development.

\end{abstract}


\maketitle

\section{Introduction}
E-graphs have recently gained popularity as a versatile data structure, with applications in synthesis, optimization, and verification via equality saturation and related techniques. The growing number of open-source e-graph implementations makes it increasingly feasible to build developer-facing tools with this technology. Python has become the go-to language for scientific computing and machine learning, thanks to its extensive ecosystem of libraries and tools. Therefore, integrating e-graph techniques with the Python ecosystem can provide significant value to developers and researchers working in these fields.

Existing e-graph libraries, such as the \verb|egg| Rust library \cite{Willsey2020eggFA}, are primarily exposed through a Rust library with macros and the ability to use custom objects as expressions, as long as they implement certain interfaces for traversal. The \verb|egg-smol| library, which came after and was inspired by the \verb|egg| library, features some improvements over its predecessor\footnote{\say{egg-smol (name temporary) is a clean slate approach to this and some other shortcomings of egg. No promises on its stabilization or merging into egg yet.} Max Willsey \cite{zulip}}. One of the main differences is that it is exposed primarily through a custom s-expression Lisp-like language, and it provides concrete types instead of allowing any Rust object as expressions with traits. \verb|egg-smol| also has built-in support for typing functions and expressions.

There are a few existing e-graph libraries in Python such as Quiche \cite{quiche} and \verb|snake-egg| \cite{snake}, which is bindings for the \verb|egg| library. Many libraries in the scientific ecosystem are looking for a representation for expressing and rewriting expressions. For example, Dask \cite{matthew_rocklin-proc-scipy-2015}, a library to execute distributed computation in Python, has been looking for a way to represent high-level expression objects and execute optimizations on them, as rewrites \cite{dask-graphs}. Another library, Ibis \cite{ibis}, which presents a pandas-like Dataframe interface, but can compile to SQL, has a similar need. They are currently trying out implementing their own e-graph library, after having tried using \verb|snake-egg| \cite{ibis-egraph}. Having a standard library shared between different libraries would consolidate maintainer time and efforts, while using e-graphs would provide benefits compared to traditional rewrite systems, such as allowing less rigid rule ordering.

Integrating e-graphs in Python could also benefit end-users if the underlying e-graph library is used by multiple libraries in similar domains, allowing users or other libraries to define conversions between the constructs defined in those libraries. This would enable end-users to continue writing their business logic in the library of their choice, while using rewrite rules to convert to another representation for optimization or execution.

\section{Python Bindings for egg-smol}
This paper presents Python bindings for the egg-smol library, primarily exposing high-level constructs that mirror the s-expression library in a "Pythonic" way\footnote{The library can be installed with \verb+pip install egg-smol+, and the source available at \url{https://github.com/metadsl/egg-smol-python}. An \href{https://egg-smol-python.readthedocs.io/en/latest/tutorials/getting-started.html}{introductory tutorial} is also available on the docs.}. This high-level API is built on top of a lower-level API, exposed to Python as the \cprotect{\href{https://egg-smol-python.readthedocs.io/en/latest/reference/bindings.html}}{\verb|egg_smol.bindings| module}, which supports all the primitives of the Rust API. These bindings are created with the help of the PyO3 Rust library \cite{pyO3}.




 \begin{figure}
   % \centering
   % \includegraphics{voltage}
   % \Description{A bell-like histogram centered at $0.5$ ̃V with most
   % measurements between $0.2$ ̃V and $0.8$ ̃V}
   \lstinputlisting[language=Python, firstline=12, basicstyle=\ttfamily\scriptsize]{eqsat_basic.py}
   \caption{High-Level Python API}
   \label{fig:high-level}
\end{figure}



A comparison between the Python API and the s-expression API can be seen in Figures \ref{fig:high-level} and \ref{fig:egg-smol}, which implements an e-graph to text the equivalence of two arithmetic  expressions.




The Python bindings utilize native Python constructs such as functions, classes, and methods, with type annotations. These constructs are translated into sort definitions and function definitions in the \verb|egg-smol| library. One notable difference between the Python bindings and the s-expression language is that variables are required to be typed in Python, whereas they are not in the s-expression language.

The requirement for typed variables in Python stems from the need for all expressions to have a known type. This aids in static analysis and code completion, as it helps disambiguate which methods are allowed based on the type. Also, in the s-expression language, everything is called as a function, which eliminates the need for typed variables. In Python, we allow classes to define the same method name, but have it translated into two different egg-smol functions. This requires knowing what class each expression has before it can be sent to \verb|egg-smol|, so we know which methods to use.




\begin{figure}
   % \centering
   % \includegraphics{voltage}
   % measurements between $0.2$ ̃V and $0.8$ ̃V}
   \lstinputlisting[language=Lisp, basicstyle=\ttfamily\scriptsize]{eqsat-basic.egg}
   \caption{Text API}
   \label{fig:egg-smol}
\end{figure}




\section{Advantages for Python Users}
The Python bindings for the \verb|egg-smol| library provide several benefits for Python users. First, the use of built-in structures familiar to Python users makes the library more accessible and easy to use. Also, by relying on the Rust library, the Python bindings take advantage of the speed and performance that Rust offers, while allowing users to benefit from the latest innovations in the e-graph world without having to reinvent existing solutions.

Compared to the bindings for the \verb|egg| library, specifically the \verb|snake-egg| API, the Python bindings for the \verb|egg-smol| library are more opinionated. In the \verb|snake-egg| API, users could bring any Python object they wanted to map to e-graphs. In contrast, the \verb|egg-smol| bindings are more restrictive, only allowing definitions through the existing function and class wrappers.

This restriction offers several advantages, especially when considering the goal of enabling rewrites between different downstream libraries. Although these libraries may define different domains, sorts, and functions, they are represented using the same meta-structure. This uniformity makes it possible to write rewrites between them, providing a significant benefit for the community as a whole. By offering a consistent and flexible interface, the \verb|egg-smol| bindings can help create a more unified ecosystem for e-graph-based optimization and rewriting in Python.

\section{Comparison for existing egg-smol Users}
The Python interface for the \verb|egg-smol| library offers several differences to existing s-expression authors. Some aspects of the language may be more verbose in Python, such as declaring variables or adding rewrites. On the other hand, Python's operator overloading allows for more succinct mathematical expressions for custom operations.

By reusing existing Python constructs and leveraging Python's class and function structures, the Python interface provides static type checking for free, with support from existing tooling like MyPy or PyLance in Visual Studio Code. As far as static type checkers are concerned, the type of decorated functions and classes is the same as the underlying object, ensuring type checking remains consistent even though the runtime representation might differ.

Static type checking is supported not only for creating expressions but also for writing rules. Rewrites must have the same type for the left and right-hand sides, which can be verified statically by Python type checkers. See Figure \ref{fig:screenshot} for an example of the static error, if you try to replace the term \verb|Num(i) * Num(j)|, which is of type \verb|Num|, with term \verb|i * j|, which is the built-in integer type. Providing type checking on these rewrites is also the reason for the more verbose fluent syntax \verb|rewrite(lhs).to(rhs)| instead of a more succinct syntax \verb|ewrite(lhs, rhs)|. The first option allows for testing that \verb|lhs| and \verb|rhs| are the same type, whereas the second does not due to restrictions of Python's type annotations.

\begin{figure*}
   \centering
   \includegraphics[width=1\textwidth]{screenshot.png}
   \caption{Type checking error in Visual Studio Code}
   \label{fig:screenshot}
\end{figure*}

Auto-completion also helps users find relevant methods for rewrites, similar to how type-checking aids in code correctness. Furthermore, the Python interface allows for interactive notebook environments, such as Jupyter, to experiment with e-graph expressions and test rewrite rules on the fly.

Overall, the Python interface exposes e-graphs to a wider audience by appealing to the large user base of the Python language and providing additional guardrails for analysis and editor integration.

\section{Future Work}
The current work represents an exciting exploration of the e-graphs space with Python bindings for the \verb|egg-smol| library. However, it is yet untested in production use cases and relies on \verb|egg-smol|, which is labeled as experimental and subject to change. There are several potential directions for future work that could aid in its adoption among Python library authors:

\subsection{Support for Embedding Existing Python Types}
For Python authors dealing with existing Python objects, it would be beneficial to explore how these could be embedded in the e-graph as leaf nodes and have rules written for them. This could potentially be achieved without any modifications upstream to \verb|egg-smol| by creating a new sort for Python objects and a function to execute arbitrary Python code as a string, given some Python objects.

\subsection{Simplifying the API for User Exposure}
If the expressions and e-graphs were to be exposed to users, we would need to develop a more straightforward API for the pipeline of taking an existing expression, running some replacements on it, and outputting that back to a native Python object. This would require adding hooks to convert the output automatically to a Python object when certain methods are called.

\subsection{Prototype with an Upstream Library}
It would be helpful to find an upstream library that already uses an internal expression system with re-rewriting and prototype how this library could be used in it, as well as what improvements would be needed beforehand. Since the Ibis library is already experimenting with e-graphs, this could be a possible option.

\subsection{Exporting and Importing E-graph Descriptions}
Currently, it is not possible to write an e-graph description in Python and then use it from the s-expression language. Adding some form of export should be possible, either by emitting the s-expression language from Python or using some other machine-readable representation, such as JSON. Ideally, this could be a bi-directional transformation, allowing for the conversion between text formats and Python source.

\subsection{Relying on Python State Management and Modules}
We could rely more heavily on Python state management and modules for encapsulation. Currently, all definitions are bound to a specific e-graph instance at runtime. However, when writing a reusable library, authors might want to separate definitions between files or modules and import several of them together into an e-graph. This would make distributing and combining different modules easier.

\subsection{Interactive Visualization in Jupyter Notebooks}
By introspecting the internal state of an \verb|egg-smol| e-graph, we could create visual and interactive views of it in Jupyter notebooks. Other libraries, like Dask and Ibis, use these visualizations as educational aids to help users understand how the library processes their expressions. Developing this type of tool could allow users to step through the e-graph's execution to understand how rules are being executed and serve as an educational tool for new users to grasp the concept of e-graphs.

\section{Conclusion}
There is a growing interest in utilizing e-graphs within the Python ecosystem, and this work presents an opportunity to open up e-graphs to a wider audience. In addition to solving concrete expression optimization problems in Python data science libraries, the \verb|egg-smol| Python bindings could help make the Python data science community as a whole more resilient and connected by providing library authors with a common language to express their domains and translate between them.

Even for users who are not currently using Python, the Python bindings present an attractive authoring experience due to the extensive tooling that already exists for the Python language. By leveraging these tools and the popularity of Python, we can foster greater adoption of e-graph techniques and facilitate collaboration and innovation across various domains.

\begin{acks}
Thank you to the Recurse Center for providing the community and support to do this work. In particular, thank you Sean Aubin for your feedback on this proposal, which was invaluable in the editing process. None of this would be possible without all of the work on the underlying Rust libraries, by Max Willsey and others. Thank you for fielding my questions about \verb|egg-smol| and be open to collaboration on it, even at such a young stage.

\end{acks}

%%
%% The next two lines define the bibliography style to be used, and
%% the bibliography file.
\bibliographystyle{ACM-Reference-Format}
\bibliography{sample-base}

%%
%% If your work has an appendix, this is the place to put it.

\end{document}
\endinput
%%
%% End of file `sample-sigplan.tex'.
